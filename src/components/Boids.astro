---
/* Full-viewport background boids layer with drag-scatter */
---
<style>
  /* Fixed, page-wide canvas behind content */
  .boids-layer {
    position: fixed;
    inset: 0;                 /* top/right/bottom/left: 0 */
    z-index: 0;               /* behind your .site-content (z-index:1) and navbar (z-index:50) */
    pointer-events: none;     /* don’t block clicks/scrolls */
  }
  .boids-layer canvas {
    width: 100%;
    height: 100%;
    display: block;
  }
</style>

<div class="boids-layer" aria-hidden="true">
  <canvas id="boids"></canvas>
</div>

<script is:inline>
  // ----- HiDPI handling -----
  const DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
  const canvas = document.getElementById('boids');
  const ctx = canvas.getContext('2d');

  function resize() {
    const w = window.innerWidth;
    const h = window.innerHeight;
    canvas.style.width = w + 'px';
    canvas.style.height = h + 'px';
    canvas.width = Math.floor(w * DPR);
    canvas.height = Math.floor(h * DPR);
    ctx.setTransform(DPR, 0, 0, DPR, 0, 0);  // crisp lines on HiDPI
  }
  resize();
  window.addEventListener('resize', resize);

  // ----- Simulation params (tuned to prevent collapse) -----
  const NUM = 300;

  // Neighborhood radii
  const ALIGN_DIST = 40;
  const COHESION_DIST = 45;
  const SEPARATION_DIST = 32;

  // Rule strengths
  const ALIGN_STRENGTH = 0.055;
  const COHESION_STRENGTH = 0.008;   // gentler cohesion
  const SEPARATION_STRENGTH = 0.45;  // stronger separation

  const MAX_SPEED = 2.2;
  const MAX_ACCEL = 0.15;            // cap instantaneous acceleration

  // Mouse attraction with dead zone and smooth falloff
  const MOUSE_MAX_FORCE = 0.05;
  const MOUSE_DEAD_RADIUS = 90;      // no attraction inside this radius
  const MOUSE_FALLOFF = 160;         // how quickly force ramps beyond dead zone

  const NOISE = 0.028;               // tiny jitter to avoid crystallizing

  // ----- Drag-scatter tuning -----
  const DRAG_SPEED_THRESHOLD = 350;  // px/s needed to start scattering
  const DRAG_REPULSE_RADIUS  = 160;  // boids within this get pushed
  const DRAG_REPULSE_MAX     = 0.65; // max extra accel from drag
  const DRAG_NOISE_BOOST     = 0.04; // extra noise while dragging fast

  // ----- State -----
  const rand = (a,b)=>a+Math.random()*(b-a);

  const boids = Array.from({length: NUM}, () => ({
    x: rand(0, canvas.width / DPR),
    y: rand(0, canvas.height / DPR),
    vx: rand(-1, 1),
    vy: rand(-1, 1),
  }));

  // Mouse with velocity tracking (for drag-scatter)
  const mouse = {
    x: window.innerWidth/2, y: window.innerHeight/2,
    px: window.innerWidth/2, py: window.innerHeight/2,
    vx: 0, vy: 0, speed: 0,
    down: false, t: performance.now()
  };

  function updateMouse(eX, eY) {
    const now = performance.now();
    const dt = Math.max(1, now - mouse.t);     // ms
    mouse.vx = (eX - mouse.px) * (1000 / dt);  // px/s
    mouse.vy = (eY - mouse.py) * (1000 / dt);  // px/s
    mouse.speed = Math.hypot(mouse.vx, mouse.vy);
    mouse.px = mouse.x; mouse.py = mouse.y;
    mouse.x = eX; mouse.y = eY;
    mouse.t = now;
  }

  // Track mouse/touch across the whole window
  window.addEventListener('mousemove', e => updateMouse(e.clientX, e.clientY));
  window.addEventListener('mousedown', ()=>mouse.down=true);
  window.addEventListener('mouseup', ()=>mouse.down=false);
  window.addEventListener('mouseleave', ()=>mouse.down=false);

  window.addEventListener('touchmove', e => {
    const t = e.touches && e.touches[0]; if (!t) return;
    updateMouse(t.clientX, t.clientY);
  }, {passive:true});
  window.addEventListener('touchstart', ()=>mouse.down=true, {passive:true});
  window.addEventListener('touchend', ()=>mouse.down=false, {passive:true});

  // ----- Helpers -----
  const limit = (vx, vy, max) => {
    const s = Math.hypot(vx, vy);
    if (s > max) { vx = vx/s*max; vy = vy/s*max; }
    return [vx, vy];
  };

  // ----- Sim step -----
  function step() {
    const W = canvas.width / DPR, H = canvas.height / DPR;

    for (let i=0;i<boids.length;i++) {
      const b = boids[i];
      let alignX=0, alignY=0, cohX=0, cohY=0, sepX=0, sepY=0;
      let alignN=0, cohN=0, sepN=0;

      // Neighborhood loop (O(n²); fine for a few hundred boids)
      for (let j=0;j<boids.length;j++) if (i!==j) {
        const o = boids[j];
        const dx = o.x - b.x, dy = o.y - b.y;
        const d = Math.hypot(dx, dy);

        if (d < ALIGN_DIST)    { alignX += o.vx; alignY += o.vy; alignN++; }
        if (d < COHESION_DIST) { cohX += o.x;   cohY += o.y;   cohN++; }
        if (d < SEPARATION_DIST){ 
          // inverse-distance push
          const inv = 1 / (d || 1);
          sepX -= dx * inv; 
          sepY -= dy * inv; 
          sepN++; 
        }
      }

      // Accumulate rule accelerations
      let ax=0, ay=0;
      if (alignN) { ax += ((alignX/alignN) - b.vx) * ALIGN_STRENGTH; ay += ((alignY/alignN) - b.vy) * ALIGN_STRENGTH; }
      if (cohN)   { ax += ((cohX/cohN) - b.x) * COHESION_STRENGTH;   ay += ((cohY/cohN) - b.y) * COHESION_STRENGTH; }
      if (sepN)   { ax += (sepX/sepN) * SEPARATION_STRENGTH;         ay += (sepY/sepN) * SEPARATION_STRENGTH; }

      // Mouse attractor with dead zone + smooth falloff & inner repulsion
      const mdx = mouse.x - b.x, mdy = mouse.y - b.y;
      let md = Math.hypot(mdx, mdy) || 1;

      if (md < MOUSE_DEAD_RADIUS) {
        // Slight repulsion inside dead zone to prevent collapse
        const push = (1 - md / MOUSE_DEAD_RADIUS) * (MOUSE_MAX_FORCE * 0.5);
        ax -= (mdx / md) * push;
        ay -= (mdy / md) * push;
      } else {
        // Outside dead zone: attraction ramps up smoothly but is capped
        const d = md - MOUSE_DEAD_RADIUS;
        // Asymptotic approach to MOUSE_MAX_FORCE
        const k = MOUSE_MAX_FORCE * (1 - Math.exp(-d / MOUSE_FALLOFF));
        const pressBoost = mouse.down ? 1.6 : 1.0;
        ax += (mdx / md) * k * pressBoost;
        ay += (mdy / md) * k * pressBoost;
      }

      // --- Drag-scatter impulse (proportional to cursor speed & proximity) ---
      if (mouse.speed > DRAG_SPEED_THRESHOLD) {
        const dxs = b.x - mouse.x, dys = b.y - mouse.y;
        const ds  = Math.hypot(dxs, dys) || 1;

        if (ds < DRAG_REPULSE_RADIUS) {
          const near   = 1 - (ds / DRAG_REPULSE_RADIUS); // 0..1 (closer = stronger)
          const speedK = Math.min(1, (mouse.speed - DRAG_SPEED_THRESHOLD) / DRAG_SPEED_THRESHOLD);
          const kick   = DRAG_REPULSE_MAX * near * (0.6 + 0.4 * speedK); // gentle onset

          // push away from cursor
          ax += (dxs / ds) * kick;
          ay += (dys / ds) * kick;

          // temporary extra randomness while dragging fast
          ax += (Math.random() - 0.5) * DRAG_NOISE_BOOST;
          ay += (Math.random() - 0.5) * DRAG_NOISE_BOOST;
        }
      }
      // (If you only want scatter while mouse is pressed, gate with: if (mouse.down && mouse.speed > DRAG_SPEED_THRESHOLD) { ... })

      // Tiny baseline noise to prevent perfect locking
      ax += (Math.random() - 0.5) * NOISE;
      ay += (Math.random() - 0.5) * NOISE;

      // Cap instantaneous acceleration
      {
        const aMag = Math.hypot(ax, ay);
        if (aMag > MAX_ACCEL) {
          ax = (ax / aMag) * MAX_ACCEL;
          ay = (ay / aMag) * MAX_ACCEL;
        }
      }

      // Integrate velocity
      b.vx += ax; b.vy += ay;
      [b.vx, b.vy] = limit(b.vx, b.vy, MAX_SPEED);

      // Integrate position
      b.x += b.vx; b.y += b.vy;

      // Wrap edges
      if (b.x < 0) b.x += W; else if (b.x >= W) b.x -= W;
      if (b.y < 0) b.y += H; else if (b.y >= H) b.y -= H;
    }
  }

  // ----- Render -----
  function draw() {
    const W = canvas.width / DPR, H = canvas.height / DPR;
    ctx.clearRect(0,0,W,H);
    ctx.lineWidth = 1;
    for (const b of boids) {
      const ang = Math.atan2(b.vy, b.vx);
      const size = 4;
      ctx.beginPath();
      ctx.moveTo(b.x + Math.cos(ang)*size*2, b.y + Math.sin(ang)*size*2);
      ctx.lineTo(b.x + Math.cos(ang+2.5)*size, b.y + Math.sin(ang+2.5)*size);
      ctx.lineTo(b.x + Math.cos(ang-2.5)*size, b.y + Math.sin(ang-2.5)*size);
      ctx.closePath();
      ctx.stroke();
    }
  }

  // ----- Loop -----
  function loop() { step(); draw(); requestAnimationFrame(loop); }
  loop();
</script>