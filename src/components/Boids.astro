---
/* no frontmatter constants; everything happens client-side */
---
<style>
  .boids-wrap { position: relative; width: 100%; height: 500px; }
  canvas { width: 100%; height: 100%; display: block; border-radius: 16px; }
</style>

<div class="boids-wrap">
  <canvas id="boids"></canvas>
</div>

<script is:inline>
  const canvas = document.getElementById('boids');
  const ctx = canvas.getContext('2d');

  function resize() {
    const r = canvas.parentElement.getBoundingClientRect();
    canvas.width = Math.floor(r.width);
    canvas.height = Math.floor(r.height);
  }
  resize();
  window.addEventListener('resize', resize);

  // Sim params (now inside client script)
  const NUM = 300;
  const MOUSE_FORCE = 0.08;
  const MAX_SPEED = 2.2;
  const ALIGN_DIST = 40;
  const COHESION_DIST = 45;
  const SEPARATION_DIST = 20;
  const ALIGN_STRENGTH = 0.05;
  const COHESION_STRENGTH = 0.03;
  const SEPARATION_STRENGTH = 0.15;

  const rand = (a,b)=>a+Math.random()*(b-a);

  const boids = Array.from({length: NUM}, () => ({
    x: rand(0, canvas.width), y: rand(0, canvas.height),
    vx: rand(-1,1), vy: rand(-1,1),
  }));

  const mouse = { x: canvas.width/2, y: canvas.height/2, down:false };
  canvas.addEventListener('mousemove', e => {
    const r = canvas.getBoundingClientRect();
    mouse.x = (e.clientX - r.left) * (canvas.width / r.width);
    mouse.y = (e.clientY - r.top)  * (canvas.height / r.height);
  });
  canvas.addEventListener('mousedown', ()=>mouse.down=true);
  canvas.addEventListener('mouseup', ()=>mouse.down=false);
  canvas.addEventListener('mouseleave', ()=>mouse.down=false);

  const limit = (vx, vy, max) => {
    const s = Math.hypot(vx, vy);
    if (s > max) { vx = vx/s*max; vy = vy/s*max; }
    return [vx, vy];
  };

  function step() {
    const W = canvas.width, H = canvas.height;

    for (let i=0;i<boids.length;i++) {
      const b = boids[i];
      let alignX=0, alignY=0, cohX=0, cohY=0, sepX=0, sepY=0;
      let alignN=0, cohN=0, sepN=0;

      for (let j=0;j<boids.length;j++) if (i!==j) {
        const o = boids[j];
        const dx = o.x - b.x, dy = o.y - b.y;
        const d = Math.hypot(dx, dy);
        if (d < ALIGN_DIST)   { alignX += o.vx; alignY += o.vy; alignN++; }
        if (d < COHESION_DIST){ cohX += o.x;   cohY += o.y;   cohN++; }
        if (d < SEPARATION_DIST){ sepX -= dx/(d||1); sepY -= dy/(d||1); sepN++; }
      }

      let ax=0, ay=0;
      if (alignN) { ax += ((alignX/alignN) - b.vx) * ALIGN_STRENGTH; ay += ((alignY/alignN) - b.vy) * ALIGN_STRENGTH; }
      if (cohN)   { ax += ((cohX/cohN) - b.x) * COHESION_STRENGTH;   ay += ((cohY/cohN) - b.y) * COHESION_STRENGTH; }
      if (sepN)   { ax += (sepX/sepN) * SEPARATION_STRENGTH;         ay += (sepY/sepN) * SEPARATION_STRENGTH; }

      // Mouse attractor
      const mdx = mouse.x - b.x, mdy = mouse.y - b.y;
      const md = Math.hypot(mdx, mdy) || 1;
      const attract = MOUSE_FORCE * (mouse.down ? 2.0 : 1.0);
      ax += (mdx/md) * attract;
      ay += (mdy/md) * attract;

      b.vx += ax; b.vy += ay;
      [b.vx, b.vy] = limit(b.vx, b.vy, MAX_SPEED);
    }

    for (const b of boids) {
      b.x += b.vx; b.y += b.vy;
      // Wrap edges
      if (b.x < 0) b.x += canvas.width; else if (b.x >= canvas.width) b.x -= canvas.width;
      if (b.y < 0) b.y += canvas.height; else if (b.y >= canvas.height) b.y -= canvas.height;
    }
  }

  function draw() {
    const W = canvas.width, H = canvas.height;
    ctx.clearRect(0,0,W,H);
    ctx.lineWidth = 1;
    for (const b of boids) {
      const ang = Math.atan2(b.vy, b.vx);
      const size = 4;
      ctx.beginPath();
      ctx.moveTo(b.x + Math.cos(ang)*size*2, b.y + Math.sin(ang)*size*2);
      ctx.lineTo(b.x + Math.cos(ang+2.5)*size, b.y + Math.sin(ang+2.5)*size);
      ctx.lineTo(b.x + Math.cos(ang-2.5)*size, b.y + Math.sin(ang-2.5)*size);
      ctx.closePath();
      ctx.stroke();
    }
  }

  function loop() { step(); draw(); requestAnimationFrame(loop); }
  loop();
</script>