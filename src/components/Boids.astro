---
/* Full-viewport background boids */
---
<style>
  /* Make this a fixed, page-wide layer behind your content */
  .boids-layer {
    position: fixed;
    inset: 0;                 /* top/right/bottom/left: 0 */
    z-index: 0;               /* behind main content (we'll set content z-index:1) */
    pointer-events: none;     /* don't block clicks/scrolls */
  }
  .boids-layer canvas {
    width: 100%;
    height: 100%;
    display: block;
  }
</style>

<div class="boids-layer" aria-hidden="true">
  <canvas id="boids"></canvas>
</div>

<script is:inline>
  const DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
  const canvas = document.getElementById('boids');
  const ctx = canvas.getContext('2d');

  function resize() {
    const w = window.innerWidth;
    const h = window.innerHeight;
    canvas.style.width = w + 'px';
    canvas.style.height = h + 'px';
    canvas.width = Math.floor(w * DPR);
    canvas.height = Math.floor(h * DPR);
    ctx.setTransform(DPR, 0, 0, DPR, 0, 0);  // crisp lines on HiDPI
  }
  resize();
  window.addEventListener('resize', resize);

  // Sim params
  const NUM = 300;
  const MOUSE_FORCE = 0.08;
  const MAX_SPEED = 2.2;
  const ALIGN_DIST = 40;
  const COHESION_DIST = 45;
  const SEPARATION_DIST = 20;
  const ALIGN_STRENGTH = 0.05;
  const COHESION_STRENGTH = 0.03;
  const SEPARATION_STRENGTH = 0.15;

  const rand = (a,b)=>a+Math.random()*(b-a);

  const boids = Array.from({length: NUM}, () => ({
    x: rand(0, canvas.width / DPR),
    y: rand(0, canvas.height / DPR),
    vx: rand(-1,1),
    vy: rand(-1,1),
  }));

  // Follow the mouse anywhere on the page (not just inside canvas)
  const mouse = { x: window.innerWidth/2, y: window.innerHeight/2, down:false };
  window.addEventListener('mousemove', e => { mouse.x = e.clientX; mouse.y = e.clientY; });
  window.addEventListener('mousedown', ()=>mouse.down=true);
  window.addEventListener('mouseup', ()=>mouse.down=false);
  window.addEventListener('mouseleave', ()=>mouse.down=false);
  // Touch support
  window.addEventListener('touchmove', e => {
    const t = e.touches[0]; if (!t) return;
    mouse.x = t.clientX; mouse.y = t.clientY;
  }, {passive:true});

  const limit = (vx, vy, max) => {
    const s = Math.hypot(vx, vy);
    if (s > max) { vx = vx/s*max; vy = vy/s*max; }
    return [vx, vy];
  };

  function step() {
    const W = canvas.width / DPR, H = canvas.height / DPR;

    for (let i=0;i<boids.length;i++) {
      const b = boids[i];
      let alignX=0, alignY=0, cohX=0, cohY=0, sepX=0, sepY=0;
      let alignN=0, cohN=0, sepN=0;

      for (let j=0;j<boids.length;j++) if (i!==j) {
        const o = boids[j];
        const dx = o.x - b.x, dy = o.y - b.y;
        const d = Math.hypot(dx, dy);
        if (d < ALIGN_DIST)    { alignX += o.vx; alignY += o.vy; alignN++; }
        if (d < COHESION_DIST) { cohX += o.x;   cohY += o.y;   cohN++; }
        if (d < SEPARATION_DIST){ sepX -= dx/(d||1); sepY -= dy/(d||1); sepN++; }
      }

      let ax=0, ay=0;
      if (alignN) { ax += ((alignX/alignN) - b.vx) * ALIGN_STRENGTH; ay += ((alignY/alignN) - b.vy) * ALIGN_STRENGTH; }
      if (cohN)   { ax += ((cohX/cohN) - b.x) * COHESION_STRENGTH;   ay += ((cohY/cohN) - b.y) * COHESION_STRENGTH; }
      if (sepN)   { ax += (sepX/sepN) * SEPARATION_STRENGTH;         ay += (sepY/sepN) * SEPARATION_STRENGTH; }

      // Mouse attractor (viewport coords already)
      const mdx = mouse.x - b.x, mdy = mouse.y - b.y;
      const md = Math.hypot(mdx, mdy) || 1;
      const attract = MOUSE_FORCE * (mouse.down ? 2.0 : 1.0);
      ax += (mdx/md) * attract;
      ay += (mdy/md) * attract;

      b.vx += ax; b.vy += ay;
      [b.vx, b.vy] = limit(b.vx, b.vy, MAX_SPEED);
      b.x += b.vx; b.y += b.vy;

      // Wrap edges
      if (b.x < 0) b.x += W; else if (b.x >= W) b.x -= W;
      if (b.y < 0) b.y += H; else if (b.y >= H) b.y -= H;
    }
  }

  function draw() {
    const W = canvas.width / DPR, H = canvas.height / DPR;
    ctx.clearRect(0,0,W,H);
    ctx.lineWidth = 1;
    for (const b of boids) {
      const ang = Math.atan2(b.vy, b.vx);
      const size = 4;
      ctx.beginPath();
      ctx.moveTo(b.x + Math.cos(ang)*size*2, b.y + Math.sin(ang)*size*2);
      ctx.lineTo(b.x + Math.cos(ang+2.5)*size, b.y + Math.sin(ang+2.5)*size);
      ctx.lineTo(b.x + Math.cos(ang-2.5)*size, b.y + Math.sin(ang-2.5)*size);
      ctx.closePath();
      ctx.stroke();
    }
  }

  function loop() { step(); draw(); requestAnimationFrame(loop); }
  loop();
</script>